"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NodeHttpExecutor = undefined;

var _bluebirdLstC;

function _load_bluebirdLstC() {
    return _bluebirdLstC = require("bluebird-lst-c");
}

var _bluebirdLstC2;

function _load_bluebirdLstC2() {
    return _bluebirdLstC2 = _interopRequireDefault(require("bluebird-lst-c"));
}

// only https proxy
let proxyFromNpm = (() => {
    var _ref = (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* () {
        let data = "";
        try {
            data = yield (0, (_fsExtraP || _load_fsExtraP()).readFile)(_path.join((0, (_os || _load_os()).homedir)(), ".npmrc"), "utf-8");
        } catch (ignored) {
            return null;
        }
        if (!data) {
            return null;
        }
        try {
            const config = (0, (_ini || _load_ini()).parse)(data);
            return config["https-proxy"] || config.proxy;
        } catch (e) {
            // used in nsis auto-updater, do not use .util.warn here
            console.warn(e);
            return null;
        }
    });

    return function proxyFromNpm() {
        return _ref.apply(this, arguments);
    };
})();
// only https url


let createAgent = (() => {
    var _ref2 = (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* () {
        let proxyString = process.env.npm_config_https_proxy || process.env.HTTPS_PROXY || process.env.https_proxy || process.env.npm_config_proxy;
        if (!proxyString) {
            proxyString = yield proxyFromNpm();
            if (!proxyString) {
                return null;
            }
        }
        const proxy = (0, (_url || _load_url()).parse)(proxyString);
        const proxyProtocol = proxy.protocol === "https:" ? "Https" : "Http";
        return require("tunnel-agent")[`httpsOver${ proxyProtocol }`]({
            proxy: {
                port: proxy.port || (proxyProtocol === "Https" ? 443 : 80),
                host: proxy.hostname,
                proxyAuth: proxy.auth
            }
        });
    });

    return function createAgent() {
        return _ref2.apply(this, arguments);
    };
})();
//# sourceMappingURL=nodeHttpExecutor.js.map


var _https;

function _load_https() {
    return _https = _interopRequireWildcard(require("https"));
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _path = _interopRequireWildcard(require("path"));

var _os;

function _load_os() {
    return _os = require("os");
}

var _ini;

function _load_ini() {
    return _ini = require("ini");
}

var _httpExecutor;

function _load_httpExecutor() {
    return _httpExecutor = require("./httpExecutor");
}

var _jsYaml;

function _load_jsYaml() {
    return _jsYaml = require("js-yaml");
}

var _url;

function _load_url() {
    return _url = require("url");
}

var _util;

function _load_util() {
    return _util = require("./util");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class NodeHttpExecutor {
    constructor() {
        this.maxRedirects = 10;
        this.httpsAgent = null;
    }
    request(url) {
        let token = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        let data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        let method = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "GET";

        const options = Object.assign({
            method: method,
            headers: {
                "User-Agent": "electron-builder"
            }
        }, url);
        if (url.hostname.indexOf("github") !== -1 && !url.path.endsWith(".yml")) {
            options.headers.Accept = "application/vnd.github.v3+json";
        }
        const encodedData = data == null ? null : new Buffer(JSON.stringify(data));
        if (encodedData != null) {
            options.method = "post";
            options.headers["Content-Type"] = "application/json";
            options.headers["Content-Length"] = encodedData.length;
        }
        return this.doApiRequest(options, token, it => it.end(encodedData));
    }
    download(url, destination, options) {
        return (this.httpsAgent || (this.httpsAgent = createAgent())).then(it => new (_bluebirdLstC2 || _load_bluebirdLstC2()).default((resolve, reject) => {
            this.doDownload(url, destination, 0, options || {}, it, error => {
                if (error == null) {
                    resolve(destination);
                } else {
                    reject(error);
                }
            });
        }));
    }
    addTimeOutHandler(request, callback) {
        request.on("socket", function (socket) {
            socket.setTimeout(60 * 1000, () => {
                callback(new Error("Request timed out"));
                request.abort();
            });
        });
    }
    doDownload(url, destination, redirectCount, options, agent, callback) {
        const ensureDirPromise = options.skipDirCreation ? (_bluebirdLstC2 || _load_bluebirdLstC2()).default.resolve() : (0, (_fsExtraP || _load_fsExtraP()).ensureDir)(_path.dirname(destination));
        const parsedUrl = (0, (_url || _load_url()).parse)(url);
        // user-agent must be specified, otherwise some host can return 401 unauthorised
        const request = (_https || _load_https()).request({
            hostname: parsedUrl.hostname,
            path: parsedUrl.path,
            headers: {
                "User-Agent": "electron-builder"
            },
            agent: agent
        }, response => {
            if (response.statusCode >= 400) {
                callback(new Error(`Cannot download "${ url }", status ${ response.statusCode }: ${ response.statusMessage }`));
                return;
            }
            const redirectUrl = response.headers.location;
            if (redirectUrl != null) {
                if (redirectCount < this.maxRedirects) {
                    this.doDownload(redirectUrl, destination, redirectCount++, options, agent, callback);
                } else {
                    callback(new Error("Too many redirects (> " + this.maxRedirects + ")"));
                }
                return;
            }
            const sha2Header = response.headers["X-Checksum-Sha2"];
            if (sha2Header != null && options.sha2 != null) {
                // todo why bintray doesn't send this header always
                if (sha2Header == null) {
                    throw new Error("checksum is required, but server response doesn't contain X-Checksum-Sha2 header");
                } else if (sha2Header !== options.sha2) {
                    throw new Error(`checksum mismatch: expected ${ options.sha2 } but got ${ sha2Header } (X-Checksum-Sha2 header)`);
                }
            }
            ensureDirPromise.then(() => {
                const fileOut = (0, (_fsExtraP || _load_fsExtraP()).createWriteStream)(destination);
                if (options.sha2 == null) {
                    response.pipe(fileOut);
                } else {
                    response.pipe(new (_httpExecutor || _load_httpExecutor()).DigestTransform(options.sha2)).pipe(fileOut);
                }
                fileOut.on("finish", () => fileOut.close(callback));
            }).catch(callback);
            let ended = false;
            response.on("end", () => {
                ended = true;
            });
            response.on("close", () => {
                if (!ended) {
                    callback(new Error("Request aborted"));
                }
            });
        });
        this.addTimeOutHandler(request, callback);
        request.on("error", callback);
        request.end();
    }
    doApiRequest(options, token, requestProcessor) {
        let redirectCount = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

        (0, (_util || _load_util()).debug)(`HTTPS request: ${ JSON.stringify(options, null, 2) }`);
        if (token != null) {
            options.headers.authorization = token.startsWith("Basic") ? token : `token ${ token }`;
        }
        return new (_bluebirdLstC2 || _load_bluebirdLstC2()).default((resolve, reject, onCancel) => {
            const request = (_https || _load_https()).request(options, response => {
                try {
                    if (response.statusCode === 404) {
                        // error is clear, we don't need to read detailed error description
                        reject(new (_httpExecutor || _load_httpExecutor()).HttpError(response, `method: ${ options.method } url: https://${ options.hostname }${ options.path }

Please double check that your authentication token is correct. Due to security reasons actual status maybe not reported, but 404.
`));
                    } else if (response.statusCode === 204) {
                        // on DELETE request
                        resolve();
                        return;
                    }
                    const redirectUrl = response.headers.location;
                    if (redirectUrl != null) {
                        if (redirectCount > 10) {
                            reject(new Error("Too many redirects (> 10)"));
                            return;
                        }
                        if (options.path.endsWith("/latest")) {
                            resolve({ location: redirectUrl });
                        } else {
                            this.doApiRequest(Object.assign({}, options, (0, (_url || _load_url()).parse)(redirectUrl)), token, requestProcessor).then(resolve).catch(reject);
                        }
                        return;
                    }
                    let data = "";
                    response.setEncoding("utf8");
                    response.on("data", chunk => {
                        data += chunk;
                    });
                    response.on("end", () => {
                        try {
                            const contentType = response.headers["content-type"];
                            const isJson = contentType != null && contentType.indexOf("json") !== -1;
                            if (response.statusCode >= 400) {
                                if (isJson) {
                                    reject(new (_httpExecutor || _load_httpExecutor()).HttpError(response, JSON.parse(data)));
                                } else {
                                    reject(new (_httpExecutor || _load_httpExecutor()).HttpError(response));
                                }
                            } else {
                                resolve(data.length === 0 ? null : isJson || !(options.path.indexOf(".yml") !== -1) ? JSON.parse(data) : (0, (_jsYaml || _load_jsYaml()).safeLoad)(data));
                            }
                        } catch (e) {
                            reject(e);
                        }
                    });
                } catch (e) {
                    reject(e);
                }
            });
            this.addTimeOutHandler(request, reject);
            request.on("error", reject);
            requestProcessor(request, reject);
            onCancel(() => request.abort());
        });
    }
}exports.NodeHttpExecutor = NodeHttpExecutor;